defmodule Mix.Tasks.Surface.Init do
  @moduledoc """
  Configures Surface on an phoenix project.

  This task is mostly meant to be used after bootstrapping a fresh Phoenix project using
  `mix phx.new`. Although it can also be used on existing non-fresh projects, some patches
  might not be applicable as they may depend on file content code/patterns that are no longer available.

  If such cases are detected, the task will inform which patches were skipped as well as provide
  instructions for manual configuration.

      $ mix surface.init

  ## Important note

  This task is still **experimental**. Make sure you have committed your work or have a proper
  backup before running it. As it may change a few files in the project, it's recommended to
  have a safe way to rollback the changes in case anything goes wrong.

  ## Options

    * `--catalogue` - Configures the experimental Surface Catalogue for the project, which
      will be available at the `/catalogue` route. For more information
      see: https://github.com/surface-ui/surface_catalogue.

    * `--demo` - Generates a sample `<Hero>` component. When used together with the `--catalogue`
      option, it additionally generates two catalogue examples and a playground for the component.

    * `--yes` - automatic answer "yes" to all prompts. Warning: this will also say "yes"
      to overwrite existing files as well as running `mix deps.get` if required.

    * `--no-formatter` - do not configure the Surface formatter.

    * `--no-js-hooks` - do not configure automatic loading of colocated JS hook files.

    * `--no-error-tag` - do not configure the `ErrorTag` component to use
      the `ErrorHelpers.translate_error/1` function generated by `mix phx.new` when Gettext
      support is detected.

  """

  use Mix.Task

  alias Mix.Tasks.Surface.Init.FilePatcher
  alias Mix.Tasks.Surface.Init.ExPatcher
  alias Mix.Tasks.Surface.Init.Patches

  @switches [
    formatter: :boolean,
    catalogue: :boolean,
    demo: :boolean,
    yes: :boolean,
    js_hooks: :boolean,
    error_tag: :boolean
  ]

  @default_opts [
    formatter: true,
    catalogue: false,
    demo: false,
    yes: false,
    js_hooks: true,
    error_tag: true
  ]

  @template_folder "priv/templates/surface.init"

  @doc false
  def run(args) do
    opts = parse_opts(args)
    assigns = init_assigns(opts)

    Mix.Task.run("app.start")

    unless assigns.yes do
      message = """
      This task will change existing files in your project.

      Make sure you commit your work before running it, especially if this is not a fresh phoenix project.
      """

      Mix.shell().info([:yellow, "\nNote: ", :reset, message])

      unless Mix.shell().yes?("Do you want to continue?") do
        exit(:normal)
      end
    end

    patch_files_results =
      FilePatcher.patch_files([
        patches_for(:common, assigns),
        patches_for(:formatter, assigns),
        patches_for(:error_tag, assigns),
        patches_for(:js_hooks, assigns),
        patches_for(:catalogue, assigns)
      ])

    create_files_results = [
      create_files_for(:demo, assigns),
      create_files_for(:demo_catalogue, assigns)
    ]

    FilePatcher.print_patch_results(patch_files_results ++ create_files_results)

    Mix.shell().info("")

    # TODO
    message = """
    New dependencies were added to your project. Do you want fetch them now?\
    """

    if assigns.yes || Mix.shell().yes?(message) do
      Mix.Task.run("deps.get")
    end
  end

  defp patches_for(:common, assigns) do
    %{
      context_app: context_app,
      web_module: web_module,
      web_module_path: web_module_path,
      web_path: web_path
    } = assigns

    %{
      "config/dev.exs" => [
        Patches.add_surface_live_reload_pattern_to_endpoint_config(context_app, web_module, web_path)
      ],
      web_module_path => [
        Patches.add_import_surface_to_view_macro(web_module)
      ]
    }
  end

  defp patches_for(:formatter, %{formatter: true}) do
    %{
      ".formatter.exs" => [
        Patches.add_surface_inputs_to_formatter_config(),
        Patches.add_surface_to_import_deps_in_formatter_config()
      ]
    }
  end

  defp patches_for(:error_tag, %{error_tag: true, using_gettext?: true, web_module: web_module}) do
    %{
      "config/config.exs" => [
        Patches.config_error_tag(web_module)
      ]
    }
  end

  defp patches_for(:js_hooks, %{js_hooks: true, context_app: context_app, web_module: web_module}) do
    %{
      "mix.exs" => [
        Patches.add_surface_to_mix_compilers()
      ],
      "assets/js/app.js" => [
        Patches.js_hooks()
      ],
      "config/dev.exs" => [
        Patches.add_surface_to_reloadable_compilers_in_endpoint_config(context_app, web_module)
      ]
    }
  end

  defp patches_for(:catalogue, %{catalogue: true} = assigns) do
    %{context_app: context_app, web_module: web_module, web_path: web_path} = assigns

    %{
      "mix.exs" => [
        Patches.add_surface_catalogue_to_mix_deps(),
        Patches.configure_catalogue_in_mix_exs()
      ],
      "config/dev.exs" => [
        Patches.add_catalogue_live_reload_pattern_to_endpoint_config(context_app, web_module)
      ],
      "#{web_path}/router.ex" => [
        Patches.configure_catalogue_route(web_module)
      ]
    }
  end

  defp patches_for(_, _), do: %{}

  defp create_files_for(:demo, %{demo: true, web_path: web_path} = assigns) do
    create_files(assigns, [
      {"demo/hero.ex", Path.join([web_path, "components"])}
    ])
  end

  defp create_files_for(:demo_catalogue, %{demo: true, catalogue: true, web_module: web_module} = assigns) do
    web_folder = web_module |> inspect() |> Macro.underscore()
    dest = Path.join(["priv/catalogue/", web_folder])

    create_files(assigns, [
      {"demo/example01.ex", dest},
      {"demo/example02.ex", dest},
      {"demo/playground.ex", dest}
    ])
  end

  defp create_files_for(_, _), do: []

  defp parse_opts(args) do
    {opts, _parsed} = OptionParser.parse!(args, strict: @switches)
    Keyword.merge(@default_opts, opts)
  end

  defp init_assigns(opts) do
    context_app = Mix.Phoenix.context_app()
    web_path = Mix.Phoenix.web_path(context_app)
    base = Module.concat([Mix.Phoenix.base()])
    web_module = Mix.Phoenix.web_module(base)
    web_module_path = web_module_path(context_app)
    using_gettext? = using_gettext?(web_path, web_module)

    opts
    |> Map.new()
    |> Map.merge(%{
      context_app: context_app,
      web_module: web_module,
      web_module_path: web_module_path,
      web_path: web_path,
      using_gettext?: using_gettext?
    })
  end

  defp web_module_path(ctx_app) do
    web_prefix = Mix.Phoenix.web_path(ctx_app)
    [lib_prefix, web_dir] = Path.split(web_prefix)
    Path.join(lib_prefix, "#{web_dir}.ex")
  end

  defp using_gettext?(web_path, web_module) do
    file = Path.join(web_path, "views/error_helpers.ex")
    error_helper = Module.concat(web_module, ErrorHelpers)

    file
    |> ExPatcher.parse_file!()
    |> ExPatcher.enter_defmodule(error_helper)
    |> ExPatcher.enter_def(:translate_error)
    |> ExPatcher.find_code_containing("Gettext.dngettext")
    |> ExPatcher.valid?()
  end

  defp paths(), do: [".", :surface]

  defp create_files(assigns, src_dest_list) do
    %{yes: yes} = assigns

    mapping =
      Enum.map(src_dest_list, fn {src, dest} ->
        file_name = Path.basename(src)
        {:eex, src, Path.join(dest, file_name)}
      end)

    results = copy_from(paths(), @template_folder, Map.to_list(assigns), mapping, force: yes)

    results
    |> Enum.zip(src_dest_list)
    |> Enum.map(fn
      {true, {_src, dest}} -> {:patched, "Create #{dest}", dest, ""}
      {false, {_src, dest}} -> {:already_patched, "Create #{dest}", dest, ""}
    end)
  end

  # Copied from https://github.com/phoenixframework/phoenix/blob/adfaac06992323224f94a471f5d7b95aca4c3156/lib/mix/phoenix.ex#L29
  # so we could pass the `opts` to `create_file`
  def copy_from(apps, source_dir, binding, mapping, opts \\ []) when is_list(mapping) do
    roots = Enum.map(apps, &to_app_source(&1, source_dir))

    for {format, source_file_path, target} <- mapping do
      source =
        Enum.find_value(roots, fn root ->
          source = Path.join(root, source_file_path)
          if File.exists?(source), do: source
        end) || raise "could not find #{source_file_path} in any of the sources"

      case format do
        :text ->
          Mix.Generator.create_file(target, File.read!(source), opts)

        :eex ->
          Mix.Generator.create_file(target, EEx.eval_file(source, binding), opts)

        :new_eex ->
          if File.exists?(target) do
            :ok
          else
            Mix.Generator.create_file(target, EEx.eval_file(source, binding), opts)
          end
      end
    end
  end

  defp to_app_source(path, source_dir) when is_binary(path),
    do: Path.join(path, source_dir)

  defp to_app_source(app, source_dir) when is_atom(app),
    do: Application.app_dir(app, source_dir)
end
